# JDK动态代理梳理

## TODO 待补充一下CGLIB和JDK动态代理的区别
- JDK 反射+接口实现
- CGLIB 字节码+子类实现(继承方式)

## 概念
代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，
以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，
而是通过调用委托类的对象的相关方法，来提供特定的服务。

按照代理的创建时期，代理类可以分为两种。
 
- 静态代理：由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。 
- 动态代理：在程序运行时，运用反射机制动态创建而成。 

## 静态代理

静态代理每一个代理类只能为一个接口服务，这样一来程序开发中必然会产生过多的代理，而且，所有的代理操作除了调用的方法不一样之外，
其他的操作都一样，则此时肯定是重复代码。解决这一问题最好的做法是可以通过一个代理类完成全部的代理功能，那么此时就必须使用动态代理完成。

## JDK动态代理

使用JDK动态代理使用到一个Proxy类和一个InvocationHandler接口。Proxy已经设计得非常优美，但是还是有一点点小小的遗憾之处，
那就是它仅支持interface代理（也就是代理类必须实现接口），因为它的设计注定了这个遗憾。

## CGLIB动态代理

对于上面说到JDK仅支持对实现接口的委托类进行代理的缺陷，这个问题CGLIB给予了很好的补位，解决了这个问题，使其委托类也可是非接口实现类。


>代理模式通常被用于AOP编程中。
如：AspectJ:编译时创建代理类，
   Spring AOP：运行时动态创建代理类：底层使用jdk的动态代理或者cjlib库来实现